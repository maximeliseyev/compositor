//
//  MetalNode.swift
//  Compositor
//
//  Created by Maxim Eliseyev on 12.08.2025.
//

import SwiftUI
import CoreImage
import Metal

// Forward declaration for MetalRenderer
protocol MetalRendererProtocol {
    var isReady: Bool { get }
    func processImage(_ image: CIImage, withShader shaderName: String, parameters: [String: Any]) async throws -> CIImage?
}



/// –ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è –Ω–æ–¥, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏—Ö Metal —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥
class MetalNode: BaseNode {
    
    // MARK: - Metal Properties
    private var metalRenderer: MetalRendererProtocol?
    private var isMetalAvailable: Bool = false
    
    // MARK: - Processing Mode
    enum ProcessingMode {
        case coreImage    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Core Image
        case metal        // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Metal
        case auto         // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤—ã–±–∏—Ä–∞—Ç—å –ª—É—á—à–∏–π –≤–∞—Ä–∏–∞–Ω—Ç
    }
    
    @Published var processingMode: ProcessingMode = .auto
    
    // MARK: - Initialization
    override init(type: NodeType, position: CGPoint) {
        super.init(type: type, position: position)
        setupMetalRenderer()
    }
    
    // MARK: - Metal Setup
    private func setupMetalRenderer() {
        // –í—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–∞–µ–º Metal —Ä–µ–Ω–¥–µ—Ä–µ—Ä –¥–æ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏
        self.isMetalAvailable = false
        print("‚ÑπÔ∏è Metal renderer temporarily disabled")
    }
    
    // MARK: - Processing Override
    override func process(inputs: [CIImage?]) -> CIImage? {
        guard inputs.first != nil else {
            return nil
        }
        
        switch processingMode {
        case .coreImage:
            return processWithCoreImage(inputs: inputs)
        case .metal:
            return processWithMetal(inputs: inputs)
        case .auto:
            return isMetalAvailable ? processWithMetal(inputs: inputs) : processWithCoreImage(inputs: inputs)
        }
    }
    
    // MARK: - Core Image Processing
    func processWithCoreImage(inputs: [CIImage?]) -> CIImage? {
        // –ë–∞–∑–æ–≤–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è - –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Ö–æ–¥–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        // –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è –≤ –ø–æ–¥–∫–ª–∞—Å—Å–∞—Ö
        return inputs.first ?? nil
    }
    
    // MARK: - Metal Processing
    private func processWithMetal(inputs: [CIImage?]) -> CIImage? {
        // Unwrap nested optionals safely
        guard let first = inputs.first else {
            print("‚ö†Ô∏è MetalNode received empty inputs")
            return nil
        }
        guard let inputImage = first else {
            print("‚ö†Ô∏è MetalNode received nil input image")
            return nil
        }
        guard let renderer = metalRenderer else {
            // Fallback to Core Image if Metal is not available
            print("‚ÑπÔ∏è Metal renderer not ready, using Core Image path")
            return processWithCoreImage(inputs: inputs)
        }
        
        // –°–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –æ–±—ë—Ä—Ç–∫–∞ –≤–æ–∫—Ä—É–≥ async –±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ MainActor
        var output: CIImage?
        var thrownError: Error?
        let group = DispatchGroup()
        group.enter()
        Task.detached(priority: .userInitiated) { [self] in
            do {
                output = try await self.processWithMetalShader(inputImage: inputImage, renderer: renderer)
            } catch {
                thrownError = error
            }
            group.leave()
        }
        group.wait()
        
        if let error = thrownError {
            print("‚ö†Ô∏è Falling back to Core Image due to Metal error: \(error)")
            return processWithCoreImage(inputs: inputs)
        }
        return output
    }
    
    // MARK: - Metal Shader Processing
    /// –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è –≤ –ø–æ–¥–∫–ª–∞—Å—Å–∞—Ö –¥–ª—è —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
    func processWithMetalShader(inputImage: CIImage, renderer: MetalRendererProtocol) async throws -> CIImage? {
        // –ë–∞–∑–æ–≤–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è - –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Ö–æ–¥–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        // –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è –≤ –ø–æ–¥–∫–ª–∞—Å—Å–∞—Ö –¥–ª—è —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
        return inputImage
    }
    
    // MARK: - Utility Methods
    
    /// –ü–æ–ª—É—á–∞–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è Metal —à–µ–π–¥–µ—Ä–∞
    func getMetalParameters() -> [String: Any] {
        var params: [String: Any] = [:]
        
        // –î–æ–±–∞–≤–ª—è–µ–º –±–∞–∑–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        for (key, value) in parameters {
            if let floatValue = value as? Float {
                params[key] = floatValue
            } else if let intValue = value as? Int {
                params[key] = Float(intValue)
            } else if let doubleValue = value as? Double {
                params[key] = Float(doubleValue)
            } else if let boolValue = value as? Bool {
                params[key] = boolValue ? 1.0 : 0.0
            }
        }
        
        return params
    }
    
    /// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å Metal
    func isMetalSupported() -> Bool {
        return isMetalAvailable && metalRenderer != nil
    }
    
    /// –ü–æ–ª—É—á–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    func getPerformanceInfo() -> String {
        if isMetalAvailable {
            return "Metal: Available"
        } else {
            return "Metal: Not available (using Core Image)"
        }
    }
}

// MARK: - Modern Unified Blur Node

/// Modern blur node with intelligent Metal/MPS processing
class BlurNode: MetalNode {
    
    @Published var radius: Float = 5.0 {
        didSet { 
            parameters["radius"] = radius
        }
    }
    
    override init(type: NodeType = .metalBlur, position: CGPoint) {
        super.init(type: type, position: position)
        setupBlurNode()
    }
    
    private func setupBlurNode() {
        // Initialize parameters (ports are created automatically from metadata)
        parameters["radius"] = radius
        parameters["blurType"] = "gaussian"
        
        print("üå´Ô∏è BlurNode initialized")
    }
    
    override func processWithMetalShader(inputImage: CIImage, renderer: MetalRendererProtocol) async throws -> CIImage? {
        let params = getMetalParameters()
        let shaderName = "gaussian_blur_compute"
        
        // Add required parameters for BlurParams
        var fullParams = params
        fullParams["textureWidth"] = Float(inputImage.extent.width)
        fullParams["textureHeight"] = Float(inputImage.extent.height)
        fullParams["dirX"] = 1.0
        fullParams["dirY"] = 0.0
        fullParams["samples"] = 0
        
        do {
            return try await renderer.processImage(
                inputImage,
                withShader: shaderName,
                parameters: fullParams
            )
        } catch {
            print("‚ùó Metal blur failed, using Core Image: \(error)")
            return processWithCoreImage(inputs: [inputImage])
        }
    }
    
    override func processWithCoreImage(inputs: [CIImage?]) -> CIImage? {
        guard let inputImage = inputs.first as? CIImage else { return nil }
        
        guard let filter = CIFilter(name: "CIGaussianBlur") else { return inputImage }
        filter.setValue(inputImage, forKey: kCIInputImageKey)
        filter.setValue(radius, forKey: kCIInputRadiusKey)
        
        return filter.outputImage?.cropped(to: inputImage.extent)
    }
}

// MARK: - Metal Node Types

/// –ù–æ–¥–∞ –¥–ª—è —Ü–≤–µ—Ç–æ–∫–æ—Ä—Ä–µ–∫—Ü–∏–∏ —á–µ—Ä–µ–∑ Metal
class MetalCorrectorNode: MetalNode {
    
    override init(type: NodeType, position: CGPoint) {
        super.init(type: type, position: position)
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ü–≤–µ—Ç–æ–∫–æ—Ä—Ä–µ–∫—Ü–∏–∏
        parameters["exposure"] = 0.0
        parameters["contrast"] = 1.0
        parameters["saturation"] = 1.0
        parameters["brightness"] = 0.0
        parameters["temperature"] = 0.0
    }
    
    override func processWithMetalShader(inputImage: CIImage, renderer: MetalRendererProtocol) async throws -> CIImage? {
        let params = getMetalParameters()
        return try await renderer.processImage(
            inputImage,
            withShader: "color_correction_fragment",
            parameters: params
        )
    }
    
    override func processWithCoreImage(inputs: [CIImage?]) -> CIImage? {
        guard let inputImage = inputs.first else { return nil }
        
        var result = inputImage
        
        // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ü–≤–µ—Ç–æ–∫–æ—Ä—Ä–µ–∫—Ü–∏—é —á–µ—Ä–µ–∑ Core Image
        if let exposure = parameters["exposure"] as? Float, exposure != 0.0 {
            let filter = CIFilter(name: "CIExposureAdjust")
            filter?.setValue(result, forKey: kCIInputImageKey)
            filter?.setValue(exposure, forKey: kCIInputEVKey)
            if let output = filter?.outputImage {
                result = output
            }
        }
        
        if let contrast = parameters["contrast"] as? Float, contrast != 1.0 {
            let filter = CIFilter(name: "CIColorControls")
            filter?.setValue(result, forKey: kCIInputImageKey)
            filter?.setValue(contrast, forKey: kCIInputSaturationKey)
            if let output = filter?.outputImage {
                result = output
            }
        }
        
        return result
    }
}

/// –ù–æ–¥–∞ –¥–ª—è —Ä–∞–∑–º—ã—Ç–∏—è —á–µ—Ä–µ–∑ Metal
class MetalBlurNode: MetalNode {
    
    override init(type: NodeType, position: CGPoint) {
        super.init(type: type, position: position)
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ä–∞–∑–º—ã—Ç–∏—è
        parameters["radius"] = 5.0
        parameters["blurType"] = "gaussian" // "gaussian" –∏–ª–∏ "box"
    }
    
    override func processWithMetalShader(inputImage: CIImage, renderer: MetalRendererProtocol) async throws -> CIImage? {
        let params = getMetalParameters()
        let blurType = parameters["blurType"] as? String ?? "gaussian"
        let shaderName = blurType == "gaussian" ? "gaussian_blur_compute" : "box_blur_compute"
        
        // –î–æ–±–∞–≤–∏–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è BlurParams
        var fullParams = params
        fullParams["textureWidth"] = Float(inputImage.extent.width)
        fullParams["textureHeight"] = Float(inputImage.extent.height)
        // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–∞–∑–º—ã—Ç–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é ‚Äî –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å
        fullParams["dirX"] = 1.0
        fullParams["dirY"] = 0.0
        fullParams["samples"] = 0
        
        do {
            return try await renderer.processImage(
                inputImage,
                withShader: shaderName,
                parameters: fullParams
            )
        } catch {
            print("‚ùó Metal blur failed, falling back to Core Image: \(error)")
            return processWithCoreImage(inputs: [inputImage])
        }
    }
    
    override func processWithCoreImage(inputs: [CIImage?]) -> CIImage? {
        guard let inputImage = inputs.first, let image = inputImage else { return nil }
        guard let radius = parameters["radius"] as? Float else { return image }
        
        let filter = CIFilter(name: "CIGaussianBlur")
        filter?.setValue(image, forKey: kCIInputImageKey)
        filter?.setValue(radius, forKey: kCIInputRadiusKey)
        
        return filter?.outputImage
    }
}
